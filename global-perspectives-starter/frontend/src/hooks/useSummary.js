import { useState, useCallback } from 'react';
import graphqlService from '../utils/graphqlService';

/**
 * Custom hook for fetching cached Gemini summaries.
 * Summaries are pre-generated by backend jobs and keyed by topicId.
 */
export const useSummary = () => {
  const [summaries, setSummaries] = useState({});
  const [loadingStates, setLoadingStates] = useState({});
  const [errors, setErrors] = useState({});

  const resolveTopicId = (articleData) => (
    articleData?.topicId ??
    articleData?.topic_id ??
    articleData?.id ??
    null
  );

  const generateSummary = useCallback(async (articleId, articleData, service = 'cache', options = {}) => {
    setLoadingStates((prev) => ({ ...prev, [articleId]: true }));
    setErrors((prev) => ({ ...prev, [articleId]: null }));

    const startTime = Date.now();

    try {
      const topicId = resolveTopicId(articleData);
      if (!topicId) {
        throw new Error('Summaries are only available for cached Gemini topics (missing topicId).');
      }

      const summaryData = await graphqlService.getTopicSummary(topicId);
      const content = summaryData?.content || '';

      const generationTime = Date.now() - startTime;
      const processedSummary = {
        content: content || 'Summary available',
        service,
        timestamp: summaryData?.generatedAt || new Date().toISOString(),
        generationTime,
        wordCount: String(content || '').split(/\s+/).filter(Boolean).length,
        articleId,
        options,
        metadata: {
          title: articleData?.title,
          url: articleData?.url,
          originalLength: articleData?.description ? articleData.description.length : 0,
          cached: summaryData?.cached ?? true,
          remainingTtlSeconds: summaryData?.remainingTtlSeconds ?? null,
        },
      };

      setSummaries((prev) => ({ ...prev, [articleId]: processedSummary }));
      return processedSummary;
    } catch (error) {
      console.error('Summary fetch failed:', error);
      const message = error?.message || 'Failed to fetch cached summary';
      setErrors((prev) => ({ ...prev, [articleId]: message }));
      throw error;
    } finally {
      setLoadingStates((prev) => ({ ...prev, [articleId]: false }));
    }
  }, []);

  const retrySummary = useCallback((articleId, articleData, service, options) => {
    return generateSummary(articleId, articleData, service, options);
  }, [generateSummary]);

  const clearSummary = useCallback((articleId) => {
    setSummaries((prev) => {
      const next = { ...prev };
      delete next[articleId];
      return next;
    });
    setErrors((prev) => {
      const next = { ...prev };
      delete next[articleId];
      return next;
    });
  }, []);

  const clearAllSummaries = useCallback(() => {
    setSummaries({});
    setErrors({});
    setLoadingStates({});
  }, []);

  const getSummary = useCallback((articleId) => summaries[articleId] || null, [summaries]);
  const isLoading = useCallback((articleId) => loadingStates[articleId] || false, [loadingStates]);
  const getError = useCallback((articleId) => errors[articleId] || null, [errors]);

  const exportSummary = useCallback((articleId, format = 'json') => {
    const summary = summaries[articleId];
    if (!summary) return null;

    if (format === 'json') return JSON.stringify(summary, null, 2);
    if (format === 'text') {
      return [
        `Title: ${summary.metadata?.title ?? 'Unknown'}`,
        '',
        'Summary:',
        summary.content,
        '',
        `Generated by: ${summary.service}`,
        `Generation time: ${summary.generationTime}ms`,
        `Word count: ${summary.wordCount}`,
        `Timestamp: ${summary.timestamp}`,
      ].join('\n');
    }

    return summary;
  }, [summaries]);

  return {
    summaries,
    loadingStates,
    errors,
    generateSummary,
    retrySummary,
    clearSummary,
    clearAllSummaries,
    getSummary,
    isLoading,
    getError,
    exportSummary,
    totalSummaries: Object.keys(summaries).length,
    hasAnySummaries: Object.keys(summaries).length > 0,
    hasAnyErrors: Object.keys(errors).length > 0,
    hasAnyLoading: Object.values(loadingStates).some(Boolean),
  };
};

export default useSummary;
